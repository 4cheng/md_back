## 三五法则
在 C++ 中三五法则指的是：
- 析构函数
- 拷贝构造
- 赋值构造
- 移动构造
- 移动赋值

### 拷贝构造和拷贝赋值

首先需要说明的一个知识点：浅拷贝、深拷贝。简单来说，浅拷贝只复制指针，两个指针指向的内存空间是一样的；而深拷贝会将指针指向的空间一起复制，这样就会创建新的内存空间，show me the code:
``` C++
int i = 102;
int *ptr = &i;

int *ktr = nullptr;
ktr = ptr;

*ktr = 2048   // 修改 ktr 指针指向的内容

cout << *ptr << endl; // 2048
```

#### 拷贝构造
指使用一个对象来直接初始化当前声明的对象，对应的拷贝构造函数 `className(const className& other)`
##### exa:
``` c++
class Buz {
private:
    int m_size;
    int *m_array;
public:
    explicit Buz(int size = 4) : m_size(size), m_array(new int[size]){
        puts("ctor");
    }
    ~Buz() {delete[] m_array;}

    Buz(const Buz& other);

    const int &operator[] (int index) const {return m_array[index];}
    int &operator[] (int index) {return m_array[index];}
};

// 浅拷贝
    Buz::Buz(const Buz& other) : m_size(other.m_size), m_array(other.m_array) {
        puts("copy ctor");
    }

// 深拷贝
    Buz::Buz(const Buz& other) : m_size(other.m_size), m_array(new int[other.m_size]) {
        memcpy(m_array, other.m_array, other.m_size * sizeof(int));
        puts("copy ctor");
    }
```

**Point**: 拷贝构造函数必须接收一个常量的对象引用

##### 发生时机：
1. 由系统自动调用
2. 显式初始化：`Buz buz{1024}; Buz puz = buz // 此时会调用拷贝构造函数`
3. 如果一个函数的形参为值类型的话，使用实参初始化形参时也会调用拷贝构造函数：
   ``` C++
    void foo(Buz b){}
    Buz buz{1024};
    foo(buz);
   ```

#### 拷贝赋值
拷贝赋值是一个重载函数，重载函数名 ： `operator = `

##### code:
``` C++
Buz &Buz::operator = (const Buz& rhs) {
    Buz temp = Buz(rhs);

    using std::swap;
    swap(this->m_size, temp.m_size);
    swap(this->m_array, temp.array);

    return *this;
}
```

##### 发生时机
除了使用其它对象直接初始化当前对象的场景外，所有带 `=` 的语句都会触发拷贝赋值
``` c++
Buz buz(10);

for (int i = 0; i < 10; i++) buz[i] = i;

Buz puz;

puz = buz; // 拷贝赋值函数将被调用，此时 buz, puz 是完全不同的对象，成员变量 m_array 所指向的地址也不相同

```