## C++



## 计算机网络

#### TCP 状态转移图

![image-20210714140708275](http://60.205.225.187/images/2021/07/14/20210714140715.png)

#### IP 头部

![image-20210714141154839](http://60.205.225.187/images/2021/07/14/20210714141154.png)

####  TCP 头部

![image-20210714141332907](http://60.205.225.187/images/2021/07/14/20210714141332.png)

####  UDP 头部

![image-20210714141742453](http://60.205.225.187/images/2021/07/14/20210714141742.png)

####  体系结构

![image-20210714160702823](http://60.205.225.187/images/2021/07/14/20210714160702.png)

####  三次握手

![image-20210714160800684](http://60.205.225.187/images/2021/07/14/20210714160800.png)

####  四次挥手

![image-20210714160809025](http://60.205.225.187/images/2021/07/14/20210714160809.png)

####  交换机与路由器的区别



#### TIME_WAIT(2MSL)



#### TCP 滑动窗口



####  TCP 可靠传输



#### TCP 流量控制



#### TCP 拥塞控制



#### 网络编程步骤

![TCP](http://60.205.225.187/images/2021/07/14/20210714163202.png)

![UDP](http://60.205.225.187/images/2021/07/14/20210714163340.png)

#### TCP 和 UDP 区别
- TCP 面向连接（三次握手），通信前需要先建立连接；UDP 面向无连接，通信前不需要连接。
- TCP 通过序列号、重传、流量控制、拥塞控制实现可靠传输；UDP 不保障可靠传输，尽最大努力交付
- TCP 面向字节流传输，因此可以被分割并在接收端重组；UDP 面向数据报传输


#### TCP 为什么是三次握手而不是两次握手
如果仅两次连接可能出现一种情况： 客户端发送完连接报文后（第一次握手）由于网络不好，延时很久后报文到达服务端，服务端接收到报文后向客户端发起连接（第二次握手）。此时客户端会认为此报文为失效报文，但在两次握手情况下服务端会认位已经建立连接，服务端户籍一直等待客户端发送数据，但因为客户端认为服务端第二次握手的回复是对失效请求的回复，不会去处理。这就造成了服务端一直等待客户端数据的情况，浪费资源。


#### TCP 为什么是四次挥手而不是三次
TCP 是全双工的，它允许两个方向的数据传输被独立关闭。当主动发起关闭的一方关闭连接之后，TCP 进入半关闭状态，此时主动方可以只关闭输出流。
之所以不是三次而是四次，主要是因为被动关闭方将“对主动关闭报文的确认”和“关闭连接”两个操作分两次进行。对主动关闭报文的确认是为了快速告知主动关闭方，此关闭连接报文已经收到。此时被动方不立即关闭连接是为了将缓存中剩下的数据从输出流发回主动关闭方。


#### DNS



#### Web 页面请求过程



#### HTTP 请求报文

![image-20210714163708086](http://60.205.225.187/images/2021/07/14/20210714163708.png)

#### HTTP 响应报文

![image-20210714163724116](http://60.205.225.187/images/2021/07/14/20210714163724.png)

#### HTTPs

![image-20210714164023584](http://60.205.225.187/images/2021/07/14/20210714164023.png)

#### HTTP 1.1 和 1.0 区别

#### HTTP 2.0 特点



#### TCP UDP 相关协议和端口号
| TCP | 协议 | 端口号 | 
| -- | -- | -- |
| Telnet |  终端模拟 | 23 |
| SMTP | 简单邮件传输协议 | 25|
| POP3 | | 110|
| IMAP4 |  |143 | 
| HTTP |  | 80|
| HTTPS |  | 443|
| SSH |  | 22 |
| FTP | 文件传输协议 | 20、 21|
| DNS |  | 53 | 

| UDP | 协议 | 端口号 | 
| -- | -- | -- |
| DNS |  | 53 | 
| TFTP | 简单文件传输协议 | 69|
| DHCP | 动态主机配置协议| 67 |

**DNS:**
1. DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； 
2. 为什么既使用TCP又使用UDP？ 

	首先了解一下TCP与UDP传送字节的长度限制： 
	UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。 
	区域传送时使用TCP，主要有一下两点考虑： 1.辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 2.TCP是一种可靠的连接，保证了数据的准确性。 



## 操作系统

#### 进程间通信方式



#### 常见信号



#### 父进程 fork 后 父子进程共享的内容



#### Linux 程序启动过程

在 shell 中输入执行的命令，内核创建一个进程，在这个进程空间中加载可执行程序的代码段和数据段，也会加载动态链接器的代码和数据。之后内核将控制传递给动态链接器里面的代码。然后动态连接器加载程序所使用的各种动态库。加载完后才将控制传递给程序的 main 函数



#### 产生死锁的四个条件

1.  互斥条件
2.  占有且等待
3.  不可强行占有
4.  循环等待

#### 处理死锁的方法



#### 线程和进程之间的区别

1.  进程拥有独立的堆栈空间和数据段，系统开销比较大；线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，切换速度也比进程快，效率高。但是正由于进程之间独立的特点，让进程安全性比较高，也因进程有独立的地址空间，一个进程崩溃之后，在保护模式下不会对其它进程造成影响，而线程只是一个进程中的不同执行路劲，一个线程死掉就等于整个进程死掉。
2.  通信机制上，进程之间独立，通信机制相对复杂，如管道、信号、消息队列、共享内存、套接字；线程由于共享内存所以通信很方便
3.  属于同一个进程的线程共享该进程的所有资源，包括文件描述符。
4.  线程只能属于一个进程，进程可以拥有多个线程

#### 线程与进程的选择

1.  需要频繁创建和销毁的优先使用线程
2.  线程的切换速度快，所以在需要大量计算，切换频繁时用线程，耗时操作用线程可以提高应用程序的相应。
3.  对 CPU 系统的效率使用上线程更占优，所以可能要发展到多级分布的用线程，多核分布用线程
4.  并行操作时使用线程，
5.  需要更稳定安全时，适合选进程；需要速度，选线程









## 数据库



## 项目

