<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [C++](#c)
- [计算机网络](#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C)
    - [TCP 状态转移图](#tcp-%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE)
    - [IP 头部](#ip-%E5%A4%B4%E9%83%A8)
    - [TCP 头部](#tcp-%E5%A4%B4%E9%83%A8)
    - [UDP 头部](#udp-%E5%A4%B4%E9%83%A8)
    - [体系结构](#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)
    - [三次握手](#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
    - [四次挥手](#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
    - [交换机与路由器的区别](#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [TIME_WAIT(2MSL)](#time_wait2msl)
    - [TCP 滑动窗口](#tcp-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3)
    - [TCP 可靠传输](#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93)
    - [TCP 流量控制](#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6)
    - [TCP 拥塞控制](#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
    - [流量控制与拥塞控制的区别](#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [网络编程步骤](#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%AD%A5%E9%AA%A4)
    - [阻塞和非阻塞 I/O 的区别](#%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-io-%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [同步和异步的却别](#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8D%B4%E5%88%AB)
    - [Reactor 和 Proactor 的区别](#reactor-%E5%92%8C-proactor-%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [TCP 和 UDP 区别](#tcp-%E5%92%8C-udp-%E5%8C%BA%E5%88%AB)
    - [TCP 为什么是三次握手而不是两次握手](#tcp-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B)
    - [TCP 为什么是四次挥手而不是三次](#tcp-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%89%E6%AC%A1)
    - [DNS](#dns)
    - [Web 页面请求过程](#web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B)
    - [HTTP 请求报文](#http-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87)
    - [HTTP 响应报文](#http-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87)
    - [HTTPs](#https)
    - [HTTP 1.1 和 1.0 区别](#http-11-%E5%92%8C-10-%E5%8C%BA%E5%88%AB)
    - [HTTP 2.0 特点](#http-20-%E7%89%B9%E7%82%B9)
    - [HTTP 状态码](#http-%E7%8A%B6%E6%80%81%E7%A0%81)
    - [TCP UDP 相关协议和端口号](#tcp-udp-%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7)
- [操作系统](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
    - [线程和进程之间的区别](#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [线程与进程的选择](#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%89%E6%8B%A9)
    - [进程间通信方式](#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F)
    - [常见信号](#%E5%B8%B8%E8%A7%81%E4%BF%A1%E5%8F%B7)
    - [父进程 fork 后 父子进程共享的内容](#%E7%88%B6%E8%BF%9B%E7%A8%8B-fork-%E5%90%8E-%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E5%86%85%E5%AE%B9)
    - [Linux 程序启动过程](#linux-%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B)
    - [产生死锁的四个条件](#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6)
    - [处理死锁的方法](#%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95)
    - [虚拟内存](#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)
    - [LRU算法](#lru%E7%AE%97%E6%B3%95)
- [Linux](#linux)
    - [Linux的 I/O 模型介绍及同步异步阻塞和非阻塞的区别](#linux%E7%9A%84-io-%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [Linux文件系统](#linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F)
    - [epoll](#epoll)
    - [常用命令](#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4)
    - [软连接和硬连接](#%E8%BD%AF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%A1%AC%E8%BF%9E%E6%8E%A5)
- [数据库](#%E6%95%B0%E6%8D%AE%E5%BA%93)
- [项目](#%E9%A1%B9%E7%9B%AE)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## C++



## 计算机网络

#### TCP 状态转移图

![image-20210714140708275](http://60.205.225.187/images/2021/07/14/20210714140715.png)

#### IP 头部

![image-20210714141154839](http://60.205.225.187/images/2021/07/14/20210714141154.png)

####  TCP 头部

![image-20210714141332907](http://60.205.225.187/images/2021/07/14/20210714141332.png)

####  UDP 头部

![image-20210714141742453](http://60.205.225.187/images/2021/07/14/20210714141742.png)

####  体系结构

![image-20210714160702823](http://60.205.225.187/images/2021/07/14/20210714160702.png)

####  三次握手

![image-20210714160800684](http://60.205.225.187/images/2021/07/14/20210714160800.png)

####  四次挥手

![image-20210714160809025](http://60.205.225.187/images/2021/07/14/20210714160809.png)

####  交换机与路由器的区别



#### TIME_WAIT(2MSL)



#### TCP 滑动窗口



####  TCP 可靠传输



#### TCP 流量控制
流量控制是为了控制发送发发送速率，保证接收方来得及接收。
接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。

#### TCP 拥塞控制

![image-20210727143003785](http://60.205.225.187/images/2021/07/27/20210727143010.png)


#### 流量控制与拥塞控制的区别
拥塞控制是防止过多数据注入网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制。

#### 网络编程步骤

![TCP](http://60.205.225.187/images/2021/07/14/20210714163202.png)

![UDP](http://60.205.225.187/images/2021/07/14/20210714163340.png)

#### 阻塞和非阻塞 I/O 的区别
- 如果内核缓冲没有数据可读时，read() 系统调用会一直等待有数据来后才从阻塞态返回，这就是阻塞
- 反之，如果立即返回给用户态进程一个返回值，则为非阻塞
- 对与往缓冲区写的操作同理

#### 同步和异步的却别
- 同步 I/O 指处理 I/O 的进程和处理 I/O 操作的进程时同一个
- 异步 I/O 中 I/O 操作由操作系统完成，并不是由产生 I/O 的用户进程执行

#### Reactor 和 Proactor 的区别
- Reactor 模式是同步 I/O， 处理 I/O 操作的依旧是产生 I/O 的程序； Proactor 是异步 I/O， 产生 I/O 调用的用户进程不会等待 I/O 发生，具体 I/O 操作由操作系统完成。
- 异步 I/O 需要操作系统支持；

#### TCP 和 UDP 区别
- TCP 面向连接（三次握手），通信前需要先建立连接；UDP 面向无连接，通信前不需要连接。
- TCP 通过序列号、重传、流量控制、拥塞控制实现可靠传输；UDP 不保障可靠传输，尽最大努力交付
- TCP 面向字节流传输，因此可以被分割并在接收端重组；UDP 面向数据报传输


#### TCP 为什么是三次握手而不是两次握手
如果仅两次连接可能出现一种情况： 客户端发送完连接报文后（第一次握手）由于网络不好，延时很久后报文到达服务端，服务端接收到报文后向客户端发起连接（第二次握手）。此时客户端会认为此报文为失效报文，但在两次握手情况下服务端会认位已经建立连接，服务端户籍一直等待客户端发送数据，但因为客户端认为服务端第二次握手的回复是对失效请求的回复，不会去处理。这就造成了服务端一直等待客户端数据的情况，浪费资源。


#### TCP 为什么是四次挥手而不是三次
TCP 是全双工的，它允许两个方向的数据传输被独立关闭。当主动发起关闭的一方关闭连接之后，TCP 进入半关闭状态，此时主动方可以只关闭输出流。
之所以不是三次而是四次，主要是因为被动关闭方将“对主动关闭报文的确认”和“关闭连接”两个操作分两次进行。对主动关闭报文的确认是为了快速告知主动关闭方，此关闭连接报文已经收到。此时被动方不立即关闭连接是为了将缓存中剩下的数据从输出流发回主动关闭方。


#### DNS



#### Web 页面请求过程



#### HTTP 请求报文

![image-20210714163708086](http://60.205.225.187/images/2021/07/14/20210714163708.png)

#### HTTP 响应报文

![image-20210714163724116](http://60.205.225.187/images/2021/07/14/20210714163724.png)

#### HTTPs

![image-20210714164023584](http://60.205.225.187/images/2021/07/14/20210714164023.png)

#### HTTP 1.1 和 1.0 区别

#### HTTP 2.0 特点

#### HTTP 状态码

| 状态码 | 类别 | 原因短语 |
| -- | -- | 
| 1XX | Informational （信息性状态码） | 接受的请求正在处理 | 
| 2XX | Success（成功状态码） | 请求正常处理完毕|
|3XX| Redireciton（重定向状态码）|需要附加操作|
|4XX|Client Error（客户端错误状态码）|服务器无法处理请求|
|5XX|Server Error（服务器错误状态码）|服务器处理请求出错|

200 OK
301 永久性重定向
302 临时性重定向
400 请求报文中存在语法错误
403 请求被拒绝
404 Not Found
500 服务器正在执行请求时发生错误
503 服务器暂时停机维护


#### TCP UDP 相关协议和端口号

| TCP | 协议 | 端口号 | 
| -- | -- | -- |
| Telnet |  终端模拟 | 23 |
| SMTP | 简单邮件传输协议 | 25|
| POP3 | | 110|
| IMAP4 |  |143 | 
| HTTP |  | 80|
| HTTPS |  | 443|
| SSH |  | 22 |
| FTP | 文件传输协议 | 20、 21|
| DNS |  | 53 | 

| UDP | 协议 | 端口号 | 
| -- | -- | -- |
| DNS |  | 53 | 
| TFTP | 简单文件传输协议 | 69|
| DHCP | 动态主机配置协议| 67 |

**DNS:**
1. DNS在进行区域传输的时候使用TCP协议，其它时候则使用UDP协议； 
2. 为什么既使用TCP又使用UDP？ 

	首先了解一下TCP与UDP传送字节的长度限制： 
	UDP报文的最大长度为512字节，而TCP则允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。通常传统的UDP报文一般不会大于512字节。 
	区域传送时使用TCP，主要有一下两点考虑： 1.辅域名服务器会定时（一般时3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP，因为数据同步传送的数据量比一个请求和应答的数据量要多得多。 2.TCP是一种可靠的连接，保证了数据的准确性。 



## 操作系统

#### 线程和进程之间的区别

1.  进程拥有独立的堆栈空间和数据段，系统开销比较大；线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，切换速度也比进程快，效率高。但是正由于进程之间独立的特点，让进程安全性比较高，也因进程有独立的地址空间，一个进程崩溃之后，在保护模式下不会对其它进程造成影响，而线程只是一个进程中的不同执行路劲，一个线程死掉就等于整个进程死掉。
2.  通信机制上，进程之间独立，通信机制相对复杂，如管道、信号、消息队列、共享内存、套接字；线程由于共享内存所以通信很方便
3.  属于同一个进程的线程共享该进程的所有资源，包括文件描述符。
4.  线程只能属于一个进程，进程可以拥有多个线程

#### 线程与进程的选择

1.  需要频繁创建和销毁的优先使用线程
2.  线程的切换速度快，所以在需要大量计算，切换频繁时用线程，耗时操作用线程可以提高应用程序的相应。
3.  对 CPU 系统的效率使用上线程更占优，所以可能要发展到多级分布的用线程，多核分布用线程
4.  并行操作时使用线程，
5.  需要更稳定安全时，适合选进程；需要速度，选线程


#### 进程间通信方式



#### 常见信号



#### 父进程 fork 后 父子进程共享的内容



#### Linux 程序启动过程

在 shell 中输入执行的命令，内核创建一个进程，在这个进程空间中加载可执行程序的代码段和数据段，也会加载动态链接器的代码和数据。之后内核将控制传递给动态链接器里面的代码。然后动态连接器加载程序所使用的各种动态库。加载完后才将控制传递给程序的 main 函数



#### 产生死锁的四个条件

1.  互斥条件
2.  占有且等待
3.  不可强行占有
4.  循环等待

#### 处理死锁的方法
- 死锁预防
- 死锁避免
- 死锁检测
- 死锁解除


#### 虚拟内存


#### LRU算法


## Linux

#### Linux的 I/O 模型介绍及同步异步阻塞和非阻塞的区别


#### Linux文件系统

#### epoll

#### 常用命令

#### 软连接和硬连接







## 数据库



## 项目

